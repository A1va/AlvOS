#include "inc/mmu.h"
#include "inc/memlayout.h"
#include "inc/trap.h"
#include "kern/macro.h"

#include "kern/picirq.h"


###################################################################
# exceptions/interrupts
# 不同的 exceptions/interrupts 的处理方式和结构都不一样，可否恢复、从哪里恢复、执行的权限等级、是否有error code等
# 因此，需要为每个exceptions/interrupts设置单独的处理函数
###################################################################

/* 
 * 提供了两个宏TRAPHANDLER*，对所有interrupt进行了统一处理。
 * 接受两个宏参数，name:要生成的中断入口名字, num:中断向量. 中断向量在文件inc/trap.h中有一系列宏声明
 * 这两个宏的功能是将函数的符号声明为全局global，也就可以在文件trap.c中的C代码获得函数指针
 * 通过这些函数指针就可以初始化IDT.
 *  1.创建一个函数symbol，名字由宏参数name得到
 *  2.将这个symbol设置为全局，即定义全局函数'name'
 *  3.这个函数将中断向量压栈，并跳转到_alltraps
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* 定义全局符号'name' */	\
	.type name, @function;	/* 符号类型是函数 */		\
	.align 2;		/* 对齐函数定义的字节 */		\
	name:			/* 函数的实现从这里开始 */		\
	pushq $(num);							\
	jmp _alltraps

/* 
 * 某些中断需要error code，由CPU自动入栈error code
 * 在进入IDT的入口函数_alltraps之前，就由CPU将它和其他数据一起自动压栈了
 * 有的中断不需要error code
 * 为了统一处理这两种中断，使得它们的栈具有相同形式，对于不进行压error code操作的中断，在原本error code的位置压一个0填充，
 * 正如宏TRAPHANDLER_NOEC中的那样
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushq $0;							\
	pushq $(num);							\
	jmp _alltraps

/*
 * 为不同的trap生成入口点.
 * 中断向量8, [10, 14]有error code; 9,15为保留中断号
 * 使用这两个宏创建所有中断的入口，故所有中断都要跳转到_alltraps
 * 同时每个中断入口的创建形式都相同，也就具有了实际上的中断统一入口
 */
.text

	TRAPHANDLER_NOEC(ALV_DIVIDE, 0)      /* divide error*/ 
	TRAPHANDLER_NOEC(ALV_DEBUG, 1)      /* debug exception*/
	TRAPHANDLER_NOEC(ALV_NMI, 2)     /* non-maskable interrupt*/
	TRAPHANDLER_NOEC(ALV_BRKPT, 3)     /* breakpoint*/
	TRAPHANDLER_NOEC(ALV_OFLOW, 4)     /* overflow*/
	TRAPHANDLER_NOEC(ALV_BOUND, 5)     /* bounds check*/
	TRAPHANDLER_NOEC(ALV_ILLOP, 6)     /* illegal opcode*/
	TRAPHANDLER_NOEC(ALV_DEVICE, 7)     /* device not available*/
	TRAPHANDLER(ALV_DBLFLT, 8)      /* double fault*/
	/* #define T_COPROC  9    // reserved (not generated by recent processors)*/
	TRAPHANDLER(ALV_TSS, 10)     /* invalid task switch segment*/
	TRAPHANDLER(ALV_SEGNP, 11)      /* segment not present*/
	TRAPHANDLER(ALV_STACK, 12)      /* stack exception*/
	TRAPHANDLER(ALV_GPFLT, 13)      /* general protection fault*/
	TRAPHANDLER(ALV_PGFLT, 14)      /* page fault*/
	/* #define T_RES    15    // reserved*/
	TRAPHANDLER_NOEC(ALV_FPERR, 16)      /* floating point error*/
	TRAPHANDLER_NOEC(ALV_ALIGN, 17)      /* aligment check*/
	TRAPHANDLER_NOEC(ALV_MCHK, 18)      /* machine check*/
	TRAPHANDLER_NOEC(ALV_SIMDERR, 19)      /* SIMD floating point error*/

	TRAPHANDLER_NOEC(ALV_SYSCALL, 48) /* System call */

	/*IRQ (HW INTERRUPTS)*/
	TRAPHANDLER_NOEC(ALV_IRQ0, 32)
	TRAPHANDLER_NOEC(ALV_IRQ1, 33)
	TRAPHANDLER_NOEC(ALV_IRQ2, 34)
	TRAPHANDLER_NOEC(ALV_IRQ3, 35)
	TRAPHANDLER_NOEC(ALV_IRQ4, 36)
	TRAPHANDLER_NOEC(ALV_IRQ5, 37)
	TRAPHANDLER_NOEC(ALV_IRQ6, 38)
	TRAPHANDLER_NOEC(ALV_IRQ7, 39)
	TRAPHANDLER_NOEC(ALV_IRQ8, 40)
	TRAPHANDLER_NOEC(ALV_IRQ9, 41)
	TRAPHANDLER_NOEC(ALV_IRQ10, 42)
	TRAPHANDLER_NOEC(ALV_IRQ11, 43)
	TRAPHANDLER_NOEC(ALV_IRQ12, 44)
	TRAPHANDLER_NOEC(ALV_IRQ13, 45)
	TRAPHANDLER_NOEC(ALV_IRQ14, 46)
	TRAPHANDLER_NOEC(ALV_IRQ15, 47)

/*
 * _alltraps是所有trap handler共用的代码(中断统一入口)
 *   1.按结构Trapframe的逆序，push寄存器的值到栈，对应汇编指令pushl和popl
 *   2.为了访问内核数据和栈，加载GD_KD(内核数据段选择子)到 ds寄存器 和 es寄存器
 *   3.pushl %rsp 压栈当前栈指针，以作为 trap() 的一个参数
 *   4.调用 trap
 *
 * 逆序: 函数调用对于结构成员的寻址是根据首地址加上偏移量进行的，偏移量按照定义顺序依次增大，压栈的变量从高地址向低地址生长，恰好x86架构符合要求
 * 根据x86手册，中断产生时，处理器已经根据 gdt 中的 TSS 自动压栈部分寄存器
 * 特权转换(ss、rsp、rflags、cs、rip)，无特权转换(rflags、cs、rip) —— 无需切换到内核栈
 * trapno 和 errcode 已经被前面的宏TRAPHANDLER...处理好了，最后跳转到此继续压栈
 * 
 * env_pop_tf 之后:
 * RSP
 * 👇 low                        high
 * +--------------------------------+
 * | rip | cs | eflags |( rsp | ss )|
 * +--------------------------------+
 *
 * _alltraps 之后:
 * RSP
 * 👇 low                                                            high
 * +--------------------------------------------------------------------+
 * | regs | es | ds | trapno | errcode | rip | cs | eflags |( rsp | ss )|
 * +--------------------------------------------------------------------+
 */
.global _alltraps
_alltraps:
	# 1.按结构Trapframe的倒序(先进后出)，push寄存器的值到栈，对应汇编指令pushal和popal
	subq $8,%rsp 
	movw %ds,(%rsp)
	subq $8,%rsp
	movw %es,(%rsp)
	PUSHA

	# 2.加载 GD_KD 到 ds寄存器 和 es寄存器
	movq $GD_KD,%rax
	movq %rax,%ds
	movq %rax,%es

	# 3.为 trap(struct Trapframe *tf) 传递一个指向Trapframe的指针
	movq %rsp,%rdi

	# 4.调用函数trap
	call trap

	# 调用trap后应该调用对应的handler处理后，恢复原来的用户态环境 - 不可能返回此处(除非内核代码出现bug)，仅作调试用
	# 恢复为原来的用户态环境(未处理trap)
	POPA_
	add $8, %rsp
	movw (%rsp),%es
	add $8, %rsp
	movw (%rsp),%ds
	iret

